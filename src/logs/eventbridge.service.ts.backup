import { Injectable, Logger, Inject, forwardRef } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { RedisService } from '../common/redis/redis.service';
import { LogsGateway } from './logs.gateway';
import {
  Execution,
  ExecutionStatus,
  ExecutionType,
} from '../database/entities/execution.entity';
import { LogsService } from './logs.service';
import { ConfigService } from '@nestjs/config';
import { LogStorageService } from './services/log-storage/log-storage.service';
import { LogLevel } from '../database/entities/execution-log.entity';
import { CloudwatchService } from './services/cloudwatch/cloudwatch.service';
import { Pipeline } from '../database/entities/pipeline.entity';
import { PipelineService } from '../pipeline/pipeline.service';
import { DeploymentEventsService } from '../deployment/deployment-events.service';
import { 
  EcsEventBridgeEvent, 
  AlbTargetHealthEvent 
} from '../deployment/deployment-events.service';

export interface EventBridgeEvent {
  id: string;
  version: string;
  account: string;
  time: string;
  region: string;
  source: string;
  resources: string[];
  'detail-type': string;
  detail: CodeBuildDetail;
}

export interface CodeBuildDetail {
  'build-status': 'IN_PROGRESS' | 'SUCCEEDED' | 'FAILED' | 'STOPPED';
  'build-id': string;
  'project-name': string;
  'current-phase'?: string;
  'current-phase-context'?: string;
  'additional-information'?: {
    'build-complete'?: boolean;
    'build-number'?: number;
    initiator?: string;
    'start-time'?: string;
    'end-time'?: string;
    environment?: {
      'environment-variables'?: Array<{
        name: string;
        value: string;
        type?: string;
      }>;
    };
    logs?: {
      'group-name'?: string;
      'stream-name'?: string;
      'deep-link'?: string;
    };
  };
}

@Injectable()
export class EventBridgeService {
  private readonly logger = new Logger(EventBridgeService.name);
  private readonly useEventBridge: boolean;

  constructor(
    private readonly redisService: RedisService,
    private readonly logsGateway: LogsGateway,
    private readonly logsService: LogsService,
    private readonly configService: ConfigService,
    private readonly logStorageService: LogStorageService,
    private readonly cloudwatchService: CloudwatchService,
    @Inject(forwardRef(() => PipelineService))
    private readonly pipelineService: PipelineService,
    private readonly deploymentEventsService: DeploymentEventsService,
    @InjectRepository(Execution)
    private executionRepository: Repository<Execution>,
    @InjectRepository(Pipeline)
    private pipelineRepository: Repository<Pipeline>,
  ) {
    const envValue = this.configService.get<string>('USE_EVENTBRIDGE', 'false');
    this.useEventBridge = envValue === 'true';
    this.logger.log(
      `EventBridge integration: ${this.useEventBridge ? 'Enabled' : 'Disabled'} (USE_EVENTBRIDGE=${envValue})`,
    );
  }

  async checkDuplicate(eventId: string): Promise<boolean> {
    try {
      const isNew = await this.redisService.checkDuplicate(eventId);
      if (!isNew) {
        this.logger.debug(`Duplicate event detected: ${eventId}`);
      }
      return isNew;
    } catch (error) {
      this.logger.error(
        `Failed to check duplicate for event ${eventId}:`,
        error,
      );
      return true;
    }
  }

  async processEvent(event: EventBridgeEvent): Promise<void> {
    const { id: eventId, source, 'detail-type': detailType } = event;

    try {
      // ì´ë²¤íŠ¸ IDë¡œ ì¤‘ë³µ ì²´í¬ (ë„¤íŠ¸ì›Œí¬ ì¬ì‹œë„ ë°©ì§€)
      const isDuplicate = !(await this.checkDuplicate(eventId));
      if (isDuplicate) {
        this.logger.debug(`Skipping duplicate event: ${eventId}`);
        return;
      }

      await this.redisService.saveEventHistory(eventId, event);

      this.logger.log(
        `Processing EventBridge event: ${eventId}, Source: ${source}, Type: ${detailType}`,
      );

      // ğŸ”„ ì´ë²¤íŠ¸ ì†ŒìŠ¤ë³„ ë¼ìš°íŒ…
      if (source === 'aws.codebuild') {
        await this.handleCodeBuildEvent(event);
      } else if (source === 'aws.ecs') {
        await this.handleEcsEvent(event as EcsEventBridgeEvent);
      } else if (source === 'aws.elasticloadbalancing') {
        await this.handleAlbEvent(event as AlbTargetHealthEvent);
      } else {
        this.logger.warn(`Unknown event source: ${source}`);
      }
    } catch (error) {
      this.logger.error(
        `Failed to process EventBridge event ${eventId}:`,
        error,
      );
      throw error;
    }
  }

  /**
   * CodeBuild ì´ë²¤íŠ¸ ì²˜ë¦¬ (ê¸°ì¡´ ë¡œì§)
   */
  private async handleCodeBuildEvent(event: EventBridgeEvent): Promise<void> {
    const { detail } = event;
    const buildId = detail['build-id'];
    const buildStatus = detail['build-status'];
    const projectName = detail['project-name'];

    this.logger.log(
      `CodeBuild Event - Build: ${buildId}, Status: ${buildStatus}`,
    );

      // Debug: Check if this is a Phase Change event
      if (
        !buildStatus &&
        event['detail-type'] === 'CodeBuild Build Phase Change'
      ) {
        // Use proper type casting for phase change events
        interface PhaseChangeDetail extends CodeBuildDetail {
          'current-phase'?: string;
          'completed-phase'?: string;
          'current-phase-status'?: string;
          'completed-phase-status'?: string;
        }
        const phaseDetail = detail as PhaseChangeDetail;
        const phase =
          phaseDetail['current-phase'] || phaseDetail['completed-phase'] || '';
        const phaseStatus =
          phaseDetail['current-phase-status'] ||
          phaseDetail['completed-phase-status'] ||
          '';
        this.logger.log(
          `Phase change event - Phase: ${phase}, Status: ${phaseStatus}`,
        );

        // Phase change ì´ë²¤íŠ¸ì—ì„œë„ execution ì°¾ì•„ì„œ CloudWatch í´ë§ í™•ì¸
        const phaseExecution = await this.findExecutionByBuildId(buildId);
        if (
          phaseExecution &&
          !this.cloudwatchService.isPolling(phaseExecution.executionId)
        ) {
          this.logger.log(
            `Starting CloudWatch polling for phase change event - Execution: ${phaseExecution.executionId}`,
          );
          try {
            await this.cloudwatchService.startPolling(phaseExecution);
          } catch (error) {
            this.logger.error(
              `Failed to start CloudWatch polling: ${error instanceof Error ? error.message : 'Unknown error'}`,
            );
          }
        }

        // Phase ì •ë³´ë¥¼ WebSocketìœ¼ë¡œ ì „ì†¡
        if (phaseExecution) {
          const phaseEvent = {
            executionId: phaseExecution.executionId,
            type: 'phase-change',
            phase: String(phase || ''),
            status: String(phaseStatus || ''),
            timestamp: new Date().toISOString(),
          };
          this.logsGateway.server
            .to(`execution:${phaseExecution.executionId}`)
            .emit('phase:update', phaseEvent);
        }

        return;
      }

      // buildIdë¡œ ê¸°ì¡´ ì‹¤í–‰ ì°¾ê¸° - ë™ì¼í•œ ë¹Œë“œì˜ ì—°ì†ëœ ì´ë²¤íŠ¸ëŠ” ê°™ì€ execution ì‚¬ìš©
      let execution = await this.findExecutionByBuildId(buildId);

      if (!execution) {
        if (buildStatus === 'IN_PROGRESS') {
          // buildIdì—ì„œ UUID ì¶”ì¶œí•˜ì—¬ executionIdë¡œ ì‚¬ìš©ëœ executionì´ ìˆëŠ”ì§€ í™•ì¸
          const executionId = buildId.split(':').pop();
          execution = await this.executionRepository.findOne({
            where: { executionId },
          });

          if (execution) {
            // CodeBuild ì„œë¹„ìŠ¤ì—ì„œ ì´ë¯¸ ìƒì„±í•œ executionì´ ìˆìœ¼ë©´ awsBuildIdì™€ logStreamName ì—…ë°ì´íŠ¸
            this.logger.log(
              `Found pre-created execution ${executionId}, updating build info and starting CloudWatch polling`,
            );

            // logStreamNameì´ ì—†ìœ¼ë©´ ì„¤ì •
            if (!execution.logStreamName) {
              execution.logStreamName = executionId;
            }

            execution.awsBuildId = buildId;
            await this.executionRepository.save(execution);

            // CloudWatch í´ë§ ì‹œì‘
            try {
              this.logger.log(
                `Attempting to start CloudWatch polling for execution ${executionId}`,
              );
              await this.cloudwatchService.startPolling(execution);
              this.logger.log(
                `Successfully started CloudWatch polling for existing execution ${executionId}`,
              );
            } catch (error) {
              this.logger.error(
                `Failed to start CloudWatch polling for ${executionId}: ${error instanceof Error ? error.message : 'Unknown error'}`,
                error instanceof Error ? error.stack : undefined,
              );
            }
          } else {
            // ì •ë§ë¡œ ìƒˆë¡œìš´ executionì´ë©´ ìƒì„±
            await this.createNewExecution(buildId, projectName, event);
            return;
          }
        } else {
          this.logger.warn(
            `No execution found for build ${buildId}, status: ${buildStatus}`,
          );
          return;
        }
      }

      await this.updateExecutionStatus(execution, buildStatus, detail);

      // EventBridge ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸ëŠ” ë¡œê·¸ë¡œ ì €ì¥í•˜ì§€ ì•ŠìŒ
      // CloudWatch í´ë§ì„ í†µí•´ ì‹¤ì œ ë¹Œë“œ ë¡œê·¸ë¥¼ ê°€ì ¸ì˜´

      // Status ë³€ê²½ë§Œ WebSocketìœ¼ë¡œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
      const statusEvent = {
        executionId: execution.executionId,
        type: 'status-change',
        status: buildStatus,
        timestamp: new Date().toISOString(),
      };
      this.broadcastStatusEvent(execution.executionId, statusEvent);
      const logEvent = this.createLogEvent(execution, event) as unknown;
      this.broadcastLogEvent(execution.executionId, logEvent);

      if (
        buildStatus === 'SUCCEEDED' ||
        buildStatus === 'FAILED' ||
        buildStatus === 'STOPPED'
      ) {
        await this.finalizeExecution(execution, buildStatus);
      }
    } catch (error) {
      this.logger.error(
        `Failed to process EventBridge event ${eventId}:`,
        error,
      );
      throw error;
    }
  }

  private async findExecutionByBuildId(
    buildId: string,
  ): Promise<Execution | null> {
    try {
      const execution = await this.executionRepository.findOne({
        where: { awsBuildId: buildId },
        relations: ['project'],
      });
      return execution;
    } catch (error) {
      this.logger.error(
        `Failed to find execution for build ${buildId}:`,
        error,
      );
      return null;
    }
  }

  private async createNewExecution(
    buildId: string,
    projectName: string,
    event: EventBridgeEvent,
  ): Promise<void> {
    try {
      this.logger.log(
        `Creating new execution for build ${buildId}, project: ${projectName}`,
      );

      // Extract metadata from environment variables in build detail
      const additionalInfo = event.detail['additional-information'];
      const environment = additionalInfo?.environment;

      // í™˜ê²½ë³€ìˆ˜ì—ì„œ ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸ ì¶”ì¶œ
      let projectId = '';
      let userId = '';
      let pipelineId = '';

      if (environment?.['environment-variables']) {
        const envVars = environment['environment-variables'];
        for (const envVar of envVars) {
          if (envVar.name === 'OTTO_USER_ID') {
            userId = envVar.value;
          } else if (envVar.name === 'OTTO_PROJECT_ID') {
            projectId = envVar.value;
          } else if (envVar.name === 'OTTO_PIPELINE_ID') {
            pipelineId = envVar.value;
          } else if (envVar.name === 'PIPELINE_ID') {
            pipelineId = pipelineId || envVar.value; // fallback
          }
        }
      }

      // Fallback: Extract from project name if not found in env vars
      if (!projectId) {
        const parts = projectName.split('-');
        if (parts.length >= 4) {
          projectId = parts[2];
        }
      }

      if (!userId) {
        this.logger.warn(
          `EventBridge execution missing userId context for ${buildId}`,
        );
        userId = 'eventbridge-user'; // Default fallback
      }

      // Extract log stream name from build ID
      const logStreamName = buildId.split(':').pop(); // Get UUID part

      const execution = this.executionRepository.create({
        awsBuildId: buildId,
        status: ExecutionStatus.RUNNING,
        executionType: ExecutionType.BUILD,
        startedAt: new Date(event.time),
        projectId: projectId || 'unknown',
        userId: userId,
        pipelineId: pipelineId || '',
        logStreamName: logStreamName, // CloudWatch ë¡œê·¸ ìŠ¤íŠ¸ë¦¼ëª… ì„¤ì •
        metadata: {
          source: 'eventbridge',
          projectName,
          region: event.region,
          account: event.account,
          logGroup: additionalInfo?.logs?.['group-name'],
          logStream: additionalInfo?.logs?.['stream-name'] || logStreamName,
        },
      });

      await this.executionRepository.save(execution);
      this.logger.log(
        `Created execution ${execution.executionId} for build ${buildId} with logStream ${logStreamName}`,
      );

      // Start CloudWatch polling for actual build logs
      try {
        await this.cloudwatchService.startPolling(execution);
        this.logger.log(
          `Started CloudWatch polling for execution ${execution.executionId}`,
        );
      } catch (error) {
        this.logger.error(
          `Failed to start CloudWatch polling: ${error instanceof Error ? error.message : 'Unknown error'}`,
        );
      }
    } catch (error) {
      this.logger.error(
        `Failed to create execution for build ${buildId}:`,
        error,
      );
      throw error;
    }
  }

  private async updateExecutionStatus(
    execution: Execution,
    status: string,
    detail: CodeBuildDetail,
  ): Promise<void> {
    try {
      const statusMap: Record<string, ExecutionStatus> = {
        IN_PROGRESS: ExecutionStatus.RUNNING,
        SUCCEEDED: ExecutionStatus.SUCCESS,
        FAILED: ExecutionStatus.FAILED,
        STOPPED: ExecutionStatus.FAILED,
      };

      execution.status = statusMap[status] || execution.status;

      if (detail['additional-information']?.['end-time']) {
        execution.completedAt = new Date(
          detail['additional-information']['end-time'],
        );
      }

      if (detail['current-phase']) {
        execution.metadata = {
          ...execution.metadata,
          currentPhase: detail['current-phase'],
          currentPhaseContext: detail['current-phase-context'],
        };
      }

      await this.executionRepository.save(execution);
      this.logger.debug(
        `Updated execution ${execution.executionId} status to ${execution.status}`,
      );
    } catch (error) {
      this.logger.error(
        `Failed to update execution ${execution.executionId}: ${error instanceof Error ? error.message : 'Unknown error'}`,
        error instanceof Error ? error.stack : undefined,
      );
      throw error;
    }
  }

  private createLogEvent(
    execution: Execution,
    event: EventBridgeEvent,
  ): {
    executionId: string;
    timestamp: string;
    type: string;
    level: LogLevel;
    message: string;
    metadata: {
      buildId: string;
      status: string;
      phase?: string;
      phaseContext?: string;
      projectName: string;
      source: string;
    };
  } {
    const { detail } = event;

    return {
      executionId: execution.executionId,
      timestamp: new Date(event.time).toISOString(),
      type: 'build-status-change',
      level: this.getLogLevel(detail['build-status']),
      message: this.formatLogMessage(detail),
      metadata: {
        buildId: detail['build-id'],
        status: detail['build-status'],
        phase: detail['current-phase'],
        phaseContext: detail['current-phase-context'],
        projectName: detail['project-name'],
        source: 'eventbridge',
      },
    };
  }

  private getLogLevel(status: string): LogLevel {
    switch (status) {
      case 'SUCCEEDED':
        return LogLevel.INFO;
      case 'FAILED':
      case 'STOPPED':
        return LogLevel.ERROR;
      default:
        return LogLevel.INFO;
    }
  }

  private async saveLogToDatabase(
    execution: Execution,
    event: EventBridgeEvent,
    logEvent: {
      message: string;
      level: LogLevel;
      executionId: string;
      timestamp: string;
      type: string;
      metadata: any;
    },
  ): Promise<void> {
    try {
      const logData = {
        executionId: execution.executionId,
        timestamp: new Date(event.time),
        message: logEvent.message,
        level: logEvent.level,
      };

      await this.logStorageService.saveLogs([logData]);
      this.logger.debug(
        `Saved log to database for execution ${execution.executionId}`,
      );
    } catch (error) {
      this.logger.error(
        `Failed to save log to database for execution ${execution.executionId}:`,
        error,
      );
    }
  }

  private formatLogMessage(detail: CodeBuildDetail): string {
    const status = detail['build-status'];
    const phase = detail['current-phase'];
    const projectName = detail['project-name'];

    if (phase) {
      return `[${projectName}] Build ${status}: ${phase}`;
    }
    return `[${projectName}] Build ${status}`;
  }

  private broadcastLogEvent(executionId: string, logEvent: unknown): void {
    try {
      // Broadcast the log event through the gateway
      this.logsGateway.broadcastLogs(executionId, [logEvent]);
      this.logger.debug(`Broadcast log event for execution ${executionId}`);
    } catch (error) {
      this.logger.error(
        `Failed to process log event for execution ${executionId}:`,
        error,
      );
    }
  }

  private broadcastStatusEvent(
    executionId: string,
    statusEvent: {
      executionId: string;
      type: string;
      status: string;
      timestamp: string;
    },
  ): void {
    try {
      // Normalize AWS CodeBuild statuses to internal ExecutionStatus for frontend
      const normalized = this.mapBuildStatusToExecutionStatus(
        statusEvent.status,
      );
      // Status broadcasts now handled through status change methods
      this.logsGateway.broadcastStatusChange(executionId, normalized);
      this.logger.debug(`Broadcast status event for execution ${executionId}`);
    } catch (error) {
      this.logger.error(
        `Failed to broadcast status event for execution ${executionId}:`,
        error,
      );
    }
  }

  private mapBuildStatusToExecutionStatus(status: string): ExecutionStatus {
    switch (status) {
      case 'IN_PROGRESS':
        return ExecutionStatus.RUNNING;
      case 'SUCCEEDED':
        return ExecutionStatus.SUCCESS;
      case 'FAILED':
      case 'STOPPED':
        return ExecutionStatus.FAILED;
      default:
        // Fallback to PENDING when unknown
        return ExecutionStatus.PENDING;
    }
  }

  private async finalizeExecution(
    execution: Execution,
    status: string,
  ): Promise<void> {
    try {
      this.logger.log(
        `Finalizing execution ${execution.executionId} with status ${status}`,
      );

      // Stop CloudWatch polling
      this.cloudwatchService.stopPolling(execution.executionId);
      this.logger.log(
        `Stopped CloudWatch polling for execution ${execution.executionId}`,
      );

      const finalEvent = {
        executionId: execution.executionId,
        type: 'execution-complete',
        status,
        completedAt: new Date().toISOString(),
      };

      this.logsGateway.broadcastExecutionComplete(
        execution.executionId,
        status,
      );
      this.logsGateway.broadcastLogs(execution.executionId, [finalEvent]);

      // ğŸš€ ë¹Œë“œ ì„±ê³µ ì‹œ ìë™ ë°°í¬ íŠ¸ë¦¬ê±°
      if (status === 'SUCCEEDED') {
        await this.triggerDeploymentAfterBuild(execution);
      }
    } catch (error) {
      this.logger.error(
        `Failed to finalize execution ${execution.executionId}:`,
        error,
      );
    }
  }

  /**
   * ë¹Œë“œ ì„±ê³µ í›„ ìë™ ë°°í¬ íŠ¸ë¦¬ê±°
   * execution.awsBuildIdë¥¼ í†µí•´ pipelineì„ ì°¾ê³  ë°°í¬ ì‹œì‘
   */
  private async triggerDeploymentAfterBuild(
    execution: Execution,
  ): Promise<void> {
    try {
      this.logger.log(
        `ğŸš€ ë¹Œë“œ ì„±ê³µ! ìë™ ë°°í¬ íŠ¸ë¦¬ê±° ì‹œì‘: buildId=${execution.awsBuildId}`,
      );

      // awsBuildIdë¡œ pipeline ì°¾ê¸° (ë¹Œë“œ ì‹œ pipeline ì •ë³´ê°€ CodeBuildì— ì „ë‹¬ë¨)
      // í•˜ì§€ë§Œ executionì— pipelineIdê°€ ì§ì ‘ ì €ì¥ë˜ì–´ ìˆì§€ ì•Šìœ¼ë¯€ë¡œ,
      // buildIdì—ì„œ pipelineIdë¥¼ ì¶”ì¶œí•˜ê±°ë‚˜ metadataì—ì„œ ì°¾ì•„ì•¼ í•¨

      const projectName = execution.metadata?.projectName as string | undefined;
      if (!projectName) {
        this.logger.warn(
          `í”„ë¡œì íŠ¸ ì´ë¦„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: execution=${execution.executionId}`,
        );
        return;
      }

      // í”„ë¡œì íŠ¸ ì´ë¦„ì—ì„œ userIdì™€ projectId ì¶”ì¶œ
      // ì˜ˆ: "otto-user123-proj456" -> userId="user123", projectId="proj456"
      const nameMatch = projectName.match(/^otto-(.+)-(.+)$/);
      if (!nameMatch) {
        this.logger.warn(`í”„ë¡œì íŠ¸ ì´ë¦„ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤: ${projectName}`);
        return;
      }

      const [, userId, projectId] = nameMatch as [string, string, string];
      this.logger.log(
        `   ğŸ“‹ ì¶”ì¶œëœ ì •ë³´: userId=${userId}, projectId=${projectId}`,
      );

      // í•´ë‹¹ í”„ë¡œì íŠ¸ì˜ ê°€ì¥ ìµœê·¼ íŒŒì´í”„ë¼ì¸ ì°¾ê¸° (ecrImageUriê°€ ìˆëŠ” ê²ƒ)
      const pipeline = await this.pipelineRepository
        .createQueryBuilder('pipeline')
        .leftJoinAndSelect('pipeline.project', 'project')
        .where('project.userId = :userId', { userId })
        .andWhere('project.projectId = :projectId', { projectId })
        .andWhere('pipeline.ecrImageUri IS NOT NULL')
        .orderBy('pipeline.updatedAt', 'DESC')
        .getOne();

      if (!pipeline) {
        this.logger.warn(
          `ë°°í¬í•  íŒŒì´í”„ë¼ì¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: userId=${userId}, projectId=${projectId}`,
        );
        return;
      }

      this.logger.log(`   âœ… íŒŒì´í”„ë¼ì¸ ë°œê²¬: ${pipeline.pipelineId}`);

      // ìë™ ë°°í¬ ì‹œì‘
      this.logger.log(`   ğŸš€ ìë™ ë°°í¬ ì‹œì‘...`);
      const deploymentResult =
        await this.pipelineService.deployAfterBuildSuccess(
          pipeline.pipelineId,
          userId,
        );

      this.logger.log(`ğŸ‰ ìë™ ë°°í¬ ì™„ë£Œ!`);
      this.logger.log(`   ğŸŒ ë°°í¬ URL: https://${deploymentResult.deployUrl}`);
      this.logger.log(`   ğŸ”— ECS ì„œë¹„ìŠ¤: ${deploymentResult.ecsServiceArn}`);

      // ë°°í¬ ì™„ë£Œ ì´ë²¤íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸
      const deployEvent = {
        executionId: execution.executionId,
        type: 'deployment-complete',
        deployUrl: deploymentResult.deployUrl,
        ecsServiceArn: deploymentResult.ecsServiceArn,
        timestamp: new Date().toISOString(),
      };
      this.logsGateway.broadcastLogs(execution.executionId, [deployEvent]);
    } catch (error) {
      this.logger.error(`âŒ ìë™ ë°°í¬ ì‹¤íŒ¨: ${error}`);

      // ë°°í¬ ì‹¤íŒ¨ ì´ë²¤íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸
      const errorEvent = {
        executionId: execution.executionId,
        type: 'deployment-failed',
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
      };
      this.logsGateway.broadcastLogs(execution.executionId, [errorEvent]);
    }
  }

  /**
   * ECS ì´ë²¤íŠ¸ ì²˜ë¦¬ - ë°°í¬ ìƒíƒœ ì¶”ì 
   */
  private async handleEcsEvent(event: EcsEventBridgeEvent): Promise<void> {
    try {
      const { 'detail-type': detailType } = event;
      
      this.logger.log(`ECS Event - Type: ${detailType}`);

      if (detailType === 'ECS Service State Change') {
        await this.deploymentEventsService.handleEcsServiceStateChange(event);
      } else if (detailType === 'ECS Task State Change') {
        await this.deploymentEventsService.handleEcsTaskStateChange(event);
      } else {
        this.logger.debug(`Unhandled ECS event type: ${detailType}`);
      }
    } catch (error) {
      this.logger.error(`Failed to handle ECS event: ${error}`);
      // ECS ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹¤íŒ¨ëŠ” ë‹¤ë¥¸ ì´ë²¤íŠ¸ì— ì˜í–¥ì„ ì£¼ì§€ ì•Šë„ë¡ ì˜ˆì™¸ë¥¼ ë‹¤ì‹œ ë˜ì§€ì§€ ì•ŠìŒ
    }
  }

  /**
   * ALB ì´ë²¤íŠ¸ ì²˜ë¦¬ - íƒ€ê²Ÿ í—¬ìŠ¤ ìƒíƒœ ì¶”ì 
   */
  private async handleAlbEvent(event: AlbTargetHealthEvent): Promise<void> {
    try {
      const { 'detail-type': detailType } = event;
      
      this.logger.log(`ALB Event - Type: ${detailType}`);

      if (detailType === 'ELB Target Health State Change') {
        await this.deploymentEventsService.handleAlbTargetHealthStateChange(event);
      } else {
        this.logger.debug(`Unhandled ALB event type: ${detailType}`);
      }
    } catch (error) {
      this.logger.error(`Failed to handle ALB event: ${error}`);
      // ALB ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹¤íŒ¨ëŠ” ë‹¤ë¥¸ ì´ë²¤íŠ¸ì— ì˜í–¥ì„ ì£¼ì§€ ì•Šë„ë¡ ì˜ˆì™¸ë¥¼ ë‹¤ì‹œ ë˜ì§€ì§€ ì•ŠìŒ
    }
  }

  isEventBridgeEnabled(): boolean {
    return this.useEventBridge;
  }
}
