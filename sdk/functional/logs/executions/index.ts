/**
 * @packageDocumentation
 * @module api.functional.logs.executions
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
//================================================================
import type { IConnection } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";

import type { ExecutionResponseDto } from "../../../structures/ExecutionResponseDto";

export * as register from "./register/index";
export * as logs from "./logs/index";
export * as status from "./status/index";
export * as check_stale from "./check_stale/index";
export * as archive_url from "./archive_url/index";

/**
 * @controller LogsController.getExecutions
 * @path GET /logs/executions
 * @accessor api.functional.logs.executions.getExecutions
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function getExecutions(
  connection: IConnection,
  status?: undefined | "pending" | "running" | "success" | "failed",
  executionType?: undefined | "build" | "deploy",
  pipelineId?: undefined | string,
  projectId?: undefined | string,
  limit?: undefined | number,
  offset?: undefined | number,
): Promise<getExecutions.Output> {
  return PlainFetcher.fetch(connection, {
    ...getExecutions.METADATA,
    template: getExecutions.METADATA.path,
    path: getExecutions.path(
      status,
      executionType,
      pipelineId,
      projectId,
      limit,
      offset,
    ),
  });
}
export namespace getExecutions {
  export type Output = ExecutionResponseDto[];

  export const METADATA = {
    method: "GET",
    path: "/logs/executions",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: 200,
  } as const;

  export const path = (
    status?: undefined | "pending" | "running" | "success" | "failed",
    executionType?: undefined | "build" | "deploy",
    pipelineId?: undefined | string,
    projectId?: undefined | string,
    limit?: undefined | number,
    offset?: undefined | number,
  ) => {
    const variables: URLSearchParams = new URLSearchParams();
    for (const [key, value] of Object.entries({
      status: status,
      executionType: executionType,
      pipelineId: pipelineId,
      projectId: projectId,
      limit: limit,
      offset: offset,
    } as any))
      if (undefined === value) continue;
      else if (Array.isArray(value))
        value.forEach((elem: any) => variables.append(key, String(elem)));
      else variables.set(key, String(value));
    const location: string = "/logs/executions";
    return 0 === variables.size
      ? location
      : `${location}?${variables.toString()}`;
  };
}

/**
 * @controller LogsController.getExecutionById
 * @path GET /logs/executions/:id
 * @accessor api.functional.logs.executions.getExecutionById
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function getExecutionById(
  connection: IConnection,
  id: string,
): Promise<getExecutionById.Output> {
  return PlainFetcher.fetch(connection, {
    ...getExecutionById.METADATA,
    template: getExecutionById.METADATA.path,
    path: getExecutionById.path(id),
  });
}
export namespace getExecutionById {
  export type Output = ExecutionResponseDto;

  export const METADATA = {
    method: "GET",
    path: "/logs/executions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: 200,
  } as const;

  export const path = (id: string) =>
    `/logs/executions/${encodeURIComponent(id?.toString() ?? "null")}`;
}
